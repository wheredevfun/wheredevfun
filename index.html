<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Where’s Dev? – Hide and Rug (v2.1)</title>
  <style>
    :root {
      --bg: #0a0a0b;
      --fg: #e8e8ea;
      --muted: #9aa0a6;
      --accent: #1fd57c;
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font: 14px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace
    }

    .hud {
      position: fixed;
      inset: 12px auto auto 12px;
      z-index: 5;
      background: rgba(15, 16, 18, .7);
      border: 1px solid #1d1f23;
      border-radius: 12px;
      padding: 10px 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap
    }

    .hud strong {
      color: var(--accent)
    }

    .hud .sep {
      opacity: .2
    }

    button {
      background: #111316;
      color: #e8e8ea;
      border: 1px solid #25282e;
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer
    }

    button:hover {
      border-color: #2f343b
    }

    #canvas {
      width: 100vw;
      height: 100vh;
      display: block
    }

    .notice {
      position: fixed;
      inset: auto 12px 12px auto;
      background: rgba(15, 16, 18, .7);
      border: 1px solid #1d1f23;
      border-radius: 10px;
      padding: 8px 10px;
      color: var(--muted)
    }

    @media (max-width:700px) {
      .hud {
        inset: 8px auto auto 8px;
        padding: 8px;
        gap: 6px
      }

      button {
        padding: 6px 8px
      }
    }
  </style>
</head>

<body>
  <div class="hud">
    <div>Finds: <strong id="finds">0</strong></div>
    <span class="sep">|</span>
    <div>Last: <strong id="last">—</strong></div>
    <span class="sep">|</span>
    <div>Best: <strong id="best">—</strong></div>
    <button id="reset">Reset</button>
  </div>
  <canvas id="canvas"></canvas>
  <div class="notice">Tip: click the green dev when you spot him. He’ll yell something ridiculous and rug to a new spot.
  </div>

  <script>
    (() => {
      // ===== Palette =====
      const P = {
        devSkin: '#f7d2b5', devHood: '#1fd57c', devShade: '#119a63', jean: '#2f6abf', shoe: '#0b1220', hair: '#2a1c1a', eye: '#0b0b0b', bag: '#d9b46b', bagEdge: '#a88737',
        npcRed: '#c23333', npcRedDark: '#7a1e1e', npcBlack: '#1f2023', npcBlackDark: '#0f1012',
        fieldA: '#124521', fieldB: '#165a2a', fieldC: '#1b6f35',
        treeLeafA: '#1b5c2a', treeLeafB: '#1f6c33', trunk: '#5c4026',
        speech: '#0f1012', speechEdge: '#2b3037', shadow: 'rgba(0,0,0,.25)'
      };

      // ===== Canvas setup =====
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const DPR = Math.max(1, Math.floor(devicePixelRatio || 1));

      function resize() {
        const w = canvas.clientWidth = window.innerWidth;
        const h = canvas.clientHeight = window.innerHeight;
        canvas.width = w * DPR; canvas.height = h * DPR; ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        buildWorld();
        spawnDev();
        spawnCrowd();
      }
      window.addEventListener('resize', resize);

      // ===== RNG (seeded) =====
      let seed = (crypto.getRandomValues(new Uint32Array(1))[0] >>> 0) || 0x12345678;
      function rng() { seed ^= seed << 13; seed ^= seed >>> 17; seed ^= seed << 5; return (seed >>> 0) / 0xffffffff; }

      // Lightweight value-noise for textures
      const NGRID = 128;
      const noise = new Float32Array((NGRID + 1) * (NGRID + 1)).map(() => 0);
      for (let i = 0; i < noise.length; i++) { noise[i] = rng(); }
      function vnoise(x, y) {
        const xi = Math.floor(x), yi = Math.floor(y);
        const xf = x - xi, yf = y - yi;
        function g(ix, iy) { const i = ((ix & (NGRID)) + (iy & (NGRID)) * (NGRID + 1)); return noise[i]; }
        const n00 = g(xi, yi), n10 = g(xi + 1, yi), n01 = g(xi, yi + 1), n11 = g(xi + 1, yi + 1);
        const nx0 = n00 * (1 - xf) + n10 * xf; const nx1 = n01 * (1 - xf) + n11 * xf; return nx0 * (1 - yf) + nx1 * yf;
      }
      function fBm(x, y, octs = 3) {
        let amp = 1, freq = 1, sum = 0, norm = 0; for (let i = 0; i < octs; i++) { sum += amp * vnoise(x * freq, y * freq); norm += amp; amp *= 0.5; freq *= 2; } return sum / norm;
      }

      // ===== Helpers =====
      function rect(x, y, w, h, fill) { ctx.fillStyle = fill; ctx.fillRect(x | 0, y | 0, w | 0, h | 0); }
      function rectsOverlap(a, b) { return (a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y); }

      // ===== Actors =====
      const DEV_W = 20, DEV_H = 24; const NPC_W = 18, NPC_H = 22;
      let dev = { x: 80, y: 80, w: DEV_W, h: DEV_H, vx: 0, vy: 0, dir: 1, frame: 0, nextF: 0, hiding: true, spawnedAt: performance.now(), say: '' };
      let npcs = []; let finds = 0, best = null, last = null;

      // NEW: persistent bubble anchor
      let bubblePos = null; // {x, y} when dev starts yelling

      // ===== UI =====
      const findsEl = document.getElementById('finds');
      const lastEl = document.getElementById('last');
      const bestEl = document.getElementById('best');
      document.getElementById('reset').onclick = () => { finds = 0; best = null; last = null; updateHUD(); spawnDev(); spawnCrowd(); };
      function updateHUD() { findsEl.textContent = String(finds); lastEl.textContent = last == null ? '—' : formatMs(last); bestEl.textContent = best == null ? '—' : formatMs(best); }
      function formatMs(ms) { const s = ms / 1000; return s < 10 ? s.toFixed(2) + 's' : s < 60 ? s.toFixed(1) + 's' : (Math.floor(s / 60) + 'm ' + (s % 60).toFixed(0) + 's'); }

      // ===== World =====
      let solids = []; // rectangular blockers
      let trees = [];  // canopy blobs for background
      // REMOVED ponds entirely

      function buildWorld() {
        solids.length = 0; trees.length = 0;
        const W = canvas.clientWidth, H = canvas.clientHeight;

        // Tree clusters with trunks as solids + canopy shapes for background
        const clusters = Math.max(6, Math.floor((W * H) / 120000));
        for (let i = 0; i < clusters; i++) {
          const cx = 40 + rng() * (W - 80); const cy = 40 + rng() * (H - 80);
          const n = 3 + (rng() * 4) | 0;
          let canopy = [];
          for (let k = 0; k < n; k++) {
            const tx = cx + rng() * 60 - 30, ty = cy + rng() * 40 - 20;
            solids.push({ x: tx - 4, y: ty - 2, w: 8, h: 10, tree: true });
            canopy.push({ x: tx + rng() * 10 - 5, y: ty + rng() * 8 - 4, r: 16 + rng() * 14 });
          }
          trees.push(canopy);
        }

        // NOTE: No pond generation; also no pond solids.
      }

      // ===== Spawning =====
      function spawnDev() {
        for (let tries = 0; tries < 250; tries++) {
          const x = rng() * (canvas.clientWidth - DEV_W - 20) + 10;
          const y = rng() * (canvas.clientHeight - DEV_H - 20) + 10;
          const rectA = { x, y, w: DEV_W, h: DEV_H };
          if (!solids.some(s => rectsOverlap(rectA, s))) {
            dev.x = x; dev.y = y; dev.vx = 0; dev.vy = 0; dev.dir = rng() < 0.5 ? -1 : 1; dev.frame = 0; dev.hiding = true; dev.say = ''; dev.spawnedAt = performance.now();
            bubblePos = null; // reset bubble anchor on new spawn
            return;
          }
        }
      }

      function spawnCrowd() {
        npcs.length = 0; const N = Math.min(120, 24 + finds * 6);
        for (let i = 0; i < N; i++) {
          let x, y, rectA, tries = 0; do {
            x = rng() * (canvas.clientWidth - NPC_W - 20) + 10;
            y = rng() * (canvas.clientHeight - NPC_H - 20) + 10;
            rectA = { x, y, w: NPC_W, h: NPC_H }; tries++;
          } while (tries < 120 && solids.some(s => rectsOverlap(rectA, s)));
          const isRed = (rng() < 0.5);
          const jacket = isRed ? P.npcRed : P.npcBlack;
          const pants = isRed ? P.npcRedDark : P.npcBlackDark;
          npcs.push({ x, y, w: NPC_W, h: NPC_H, dir: rng() < 0.5 ? -1 : 1, frame: (rng() * 3) | 0, nextF: 0, vx: (rng() < 0.5 ? -1 : 1) * (24 + rng() * 40), vy: (rng() < 0.5 ? -1 : 1) * (18 + rng() * 32), jacket, pants });
        }
      }

      // ===== Rendering =====
      function drawFieldTexture() {
        const W = canvas.clientWidth, H = canvas.clientHeight;
        const step = 6; // balance detail vs perf
        for (let y = 0; y < H; y += step) {
          for (let x = 0; x < W; x += step) {
            const n = fBm(x / 90, y / 90, 4);
            const mix = n;
            function lerp(a, b, t) { return a + (b - a) * t; }
            function hexToRgb(h) { const n = parseInt(h.slice(1), 16); return [(n >> 16) & 255, (n >> 8) & 255, n & 255]; }
            function rgbToHex(r, g, b) { return '#' + [r, g, b].map(v => ('0' + (v | 0).toString(16)).slice(-2)).join(''); }
            const a = hexToRgb(P.fieldA), b = hexToRgb(P.fieldB), c = hexToRgb(P.fieldC);
            const ab = [lerp(a[0], b[0], mix), lerp(a[1], b[1], mix), lerp(a[2], b[2], mix)];
            const bc = [lerp(b[0], c[0], mix), lerp(b[1], c[1], mix), lerp(b[2], c[2], mix)];
            const m = (Math.sin((x + y) / 140) + 1) / 2; // banding
            const col = m < 0.5 ? ab : bc;
            rect(x, y, step, step, rgbToHex(col[0], col[1], col[2]));
          }
        }
      }

      function drawTrees() {
        for (const canopy of trees) {
          for (const leaf of canopy) {
            const { x, y, r } = leaf;
            const g = ctx.createRadialGradient(x, y, r * 0.2, x + 2, y + 1, r);
            g.addColorStop(0, P.treeLeafB);
            g.addColorStop(1, P.treeLeafA);
            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
          }
          for (const s of solids) { if (s.tree) { rect(s.x, s.y, s.w, s.h, P.trunk); } }
        }
      }

      function roundRect(x, y, w, h, r, fill, stroke) {
        const rr = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y); ctx.arcTo(x + w, y, x + w, y + h, rr); ctx.arcTo(x + w, y + h, x, y + h, rr);
        ctx.arcTo(x, y + h, x, y, rr); ctx.arcTo(x, y, x + w, y, rr);
        if (fill) ctx.fill(); if (stroke) ctx.stroke();
      }

      function drawDev(px, py, frame = 0, flip = false) {
        const ox = px | 0, oy = py | 0; ctx.save(); if (flip) { ctx.translate(ox + DEV_W, oy); ctx.scale(-1, 1); } else ctx.translate(ox, oy);
        rect(2, DEV_H - 3, 16, 2, P.shadow);
        rect(4, 6, 12, 9, P.devHood); rect(4, 10, 12, 1, P.devShade);
        rect(7, 7, 6, 4, P.devSkin); rect(7, 6, 6, 1, P.hair); rect(8, 8, 1, 1, P.eye); rect(11, 8, 1, 1, P.eye); if (((Date.now() / 800 | 0) % 3) !== 0) rect(9, 10, 2, 1, P.eye);
        if (frame === 0) { rect(6, 14, 3, 7, P.jean); rect(9, 14, 3, 7, P.jean); } else if (frame === 1) { rect(5, 14, 3, 7, P.jean); rect(10, 14, 3, 7, P.jean); } else { rect(7, 14, 3, 7, P.jean); rect(9, 14, 3, 7, P.jean); } rect(6, 21, 3, 1, P.shoe); rect(9, 21, 3, 1, P.shoe);
        rect(2, 13, 4, 5, P.bag); rect(2, 18, 4, 1, P.bagEdge);
        ctx.restore();
      }

      function drawNPC(px, py, frame, flip, jacket, pants) {
        const ox = px | 0, oy = py | 0; const W = NPC_W, H = NPC_H; ctx.save(); if (flip) { ctx.translate(ox + W, oy); ctx.scale(-1, 1); } else ctx.translate(ox, oy);
        rect(2, H - 3, 12, 2, P.shadow); rect(4, 5, 10, 8, jacket); rect(6, 6, 6, 3, '#f1d6c2'); rect(6, 5, 6, 1, '#2a1c1a'); rect(7, 7, 1, 1, '#0b0b0b'); rect(10, 7, 1, 1, '#0b0b0b');
        if (frame === 0) { rect(6, 13, 3, 6, pants); rect(9, 13, 3, 6, pants); } else if (frame === 1) { rect(5, 13, 3, 6, pants); rect(10, 13, 3, 6, pants); } else { rect(7, 13, 3, 6, pants); rect(9, 13, 3, 6, pants); }
        ctx.restore();
      }

      function bubble(x, y, text) {
        ctx.save(); ctx.font = '10px ui-monospace, monospace'; const pad = 6; const m = ctx.measureText(text);
        const bw = Math.max(56, m.width + pad * 2), bh = 22; const bx = Math.max(6, Math.min(x - bw / 2, canvas.clientWidth - bw - 6)); const by = Math.max(6, y - 30);
        rect(bx, by, bw, bh, P.speech); ctx.strokeStyle = P.speechEdge; ctx.strokeRect(bx + .5, by + .5, bw - 1, bh - 1);
        ctx.fillStyle = '#fff'; ctx.fillText(text, bx + pad, by + 14);
        ctx.beginPath(); ctx.moveTo(x, by + bh); ctx.lineTo(x - 4, by + bh); ctx.lineTo(x, by + bh + 6); ctx.closePath(); ctx.fillStyle = P.speech; ctx.fill(); ctx.strokeStyle = P.speechEdge; ctx.stroke();
        ctx.restore();
      }

      // ===== Random rug-reasons =====
      const RUG_LINES = [
        "brb, bridging funds",
        "audit in progress (self-audit)",
        "AMA starting… in another chain",
        "gas too high, gotta go",
        "keys in cold wallet… in another country",
        "chart needs me to step away",
        "locking liquidity (my pocket)",
        "dev multi-sig (1/1)",
        "urgent governance vote (me vs me)",
        "RPC down, spirit up",
        "deploying v2 (v0.5)",
        "tax set to 0… and me to 100",
        "sec dm’ed brb",
        "snapshot happening (my bank app)",
        "meme first, product later",
        "oops, wrong chain again",
        "investor call (mom)",
        "airdrop whitelist (friends only)",
        "partnership secured (trust me bro)",
        "audit passed (because we skipped it)"
      ];

      // ===== Game Loop =====
      let lastTS = performance.now();
      let devFoundAnim = 0; // ms of dash

      function step(ts) {
        const dt = Math.min(50, ts - lastTS); lastTS = ts;

        // Update NPCs
        for (const n of npcs) {
          n.nextF -= dt; if (n.nextF <= 0) { n.nextF = 120 + rng() * 120; n.frame = (n.frame + 1) % 3; }
          let nx = n.x + (n.vx * dt / 1000), ny = n.y + (n.vy * dt / 1000);
          const r = { x: nx, y: ny, w: n.w, h: n.h };
          if (nx < 0 || nx + n.w > canvas.clientWidth || solids.some(s => rectsOverlap(r, s))) n.vx *= -1;
          if (ny < 0 || ny + n.h > canvas.clientHeight || solids.some(s => rectsOverlap(r, s))) n.vy *= -1;
          n.x += n.vx * dt / 1000; n.y += n.vy * dt / 1000; n.dir = n.vx < 0 ? -1 : 1;
        }

        // Dev idle / dash
        if (dev.hiding) {
          dev.nextF -= dt; if (dev.nextF <= 0) { dev.nextF = 150 + rng() * 150; dev.frame = (dev.frame + 1) % 3; }
          dev.x += Math.sin(ts / 700 + seed) * 0.02; dev.y += Math.cos(ts / 900 + seed) * 0.02;
        } else if (devFoundAnim > 0) {
          devFoundAnim -= dt; dev.x += dev.dir * 0.35 * dt; dev.y -= 0.15 * dt;
        }

        // Render layers
        drawFieldTexture();
        drawTrees();
        // REMOVED: drawPonds()

        for (const n of npcs) { drawNPC(n.x, n.y, n.frame, n.dir < 0, n.jacket, n.pants); }
        drawDev(dev.x, dev.y, dev.frame, dev.dir < 0);

        // Draw bubble at anchored position if present
        if (dev.say && bubblePos) { bubble(bubblePos.x, bubblePos.y, dev.say); }

        requestAnimationFrame(step);
      }

      // ===== Input =====
      canvas.addEventListener('click', (e) => {
        const rectC = canvas.getBoundingClientRect();
        const x = (e.clientX - rectC.left); const y = (e.clientY - rectC.top);
        if (x >= dev.x && x <= dev.x + dev.w && y >= dev.y && y <= dev.y + dev.h) {
          const t = performance.now() - dev.spawnedAt; last = t; if (best == null || t < best) best = t; finds++; updateHUD();
          dev.hiding = false; dev.say = RUG_LINES[(Math.random() * RUG_LINES.length) | 0]; devFoundAnim = 650; dev.dir = (rng() < 0.5 ? -1 : 1);
          // Anchor bubble to the position at click-time (static while he runs)
          bubblePos = { x: dev.x + DEV_W / 2, y: dev.y - 4 };
          setTimeout(() => { dev.say = ''; bubblePos = null; spawnDev(); spawnCrowd(); }, 700);
        }
      });

      // ===== Boot =====
      resize(); updateHUD();
      requestAnimationFrame(step);

    })();
  </script>
</body>

</html>